

#include <condition_variable>
#include <iostream>
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <vector>

static std::mutex mtx;
static std::condition_variable condition;

template <typename T, int SIZE> class Stack {
  T array[SIZE];
  uint32_t amount{0};

public:
  Stack(const T &) = delete;
  Stack &operator=(const T &) = delete;
  Stack() = default;

  /**
   * @brief Adds a value into stack.
   *
   * @param _value
   */
  void push(const T _value) {
    std::unique_lock<std::mutex> lock{mtx};
    while (amount >= SIZE) {
      condition.wait(lock);
    }

    array[amount] = _value;
    amount++;

    lock.unlock();
    condition.notify_all();
  }

  /**
   * @brief Returns and removes top layer.
   *
   * @return The value stored at the top.
   */
  T pop(void) {
    std::unique_lock<std::mutex> lock{mtx};
    while (amount == 0) {
      condition.wait(lock);
    }

    T var = array[amount - 1];
    amount--;

    lock.unlock();
    condition.notify_all();
    return var;
  }
};

template <typename T, int SIZE>
void th_push(Stack<T, SIZE> &_stack, T start_val) {
  for (size_t i = 0; i < 5000; ++i) {
    T val = start_val + i;
    {
      std::unique_lock<std::mutex> lock{mtx};
      std::cout << "->" << val << std::endl;
    }
    _stack.push(val);
    std::this_thread::sleep_for(std::chrono::milliseconds((rand() % 50 + 1)));
  }
}

template <typename T, int SIZE> void th_pop(Stack<T, SIZE> &_stack) {
  for (size_t i = 0; i < 2500; i++) {
    T var = _stack.pop();
    {
      std::unique_lock<std::mutex> lock{mtx};
      std::cout << "<-" << var << std::endl;
    }
    std::this_thread::sleep_for(std::chrono::milliseconds((rand() % 100 + 1)));
  }
}

// test generated by Google Gemini
int main(void) {
  std::cout << "Optimized Stack Test" << std::endl;
  Stack<int, 10> stack; // Stack capacity 10

  // Create threads for both pushing and popping
  std::vector<std::thread> threads;

  // 2 Pusher threads
  threads.emplace_back(th_push<int, 10>, std::ref(stack), 0); // values 0..4999
  threads.emplace_back(th_push<int, 10>, std::ref(stack),
                       10000); // values 10000..14999

  // 4 Popper threads (adjust count as needed)
  threads.emplace_back(th_pop<int, 10>, std::ref(stack));
  threads.emplace_back(th_pop<int, 10>, std::ref(stack));
  threads.emplace_back(th_pop<int, 10>, std::ref(stack));
  threads.emplace_back(th_pop<int, 10>, std::ref(stack));

  // Wait for all threads to complete
  for (auto &th : threads) {
    if (th.joinable()) {
      th.join();
    }
  }

  return 0;
}